// Implements authentication use-case logic for user registration, login, and token management.
import { injectable, inject } from 'tsyringe';
import { sign, verify } from 'jsonwebtoken';
import { IAuthUseCase } from './interfaces/auth.usecase.interface';
import { IUserRepository } from '../repositories/interfaces/user.repository.interface';
import { AuthResponse, LoginRequest, RegisterRequest, User } from '../models/user.model';
import { AppConfig } from '../../../shared/config/app.config';
import * as bcrypt from 'bcryptjs'; // Import bcryptjs

@injectable()
export class AuthUseCase implements IAuthUseCase {
  constructor(@inject('IUserRepository') private userRepository: IUserRepository) {}

  async register(request: RegisterRequest): Promise<AuthResponse> {
    // Check if user already exists
    const existingUser = await this.userRepository.findByEmail(request.email);
    if (existingUser) {
      throw new Error('User already exists with this email');
    }

    // Hash password
    const hashedPassword = await this.hashPassword(request.password);

    // Create user
    const newUser: User = {
      id: '', // Will be generated by Prisma
      email: request.email,
      password: hashedPassword,
      name: request.name,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    const createdUser = await this.userRepository.create(newUser);

    // Generate token
    const token = this.generateToken(createdUser.id);
    const refreshToken = this.generateRefreshToken(createdUser.id);

    return {
      user: {
        id: createdUser.id,
        email: createdUser.email,
        name: createdUser.name,
        createdAt: createdUser.createdAt,
        updatedAt: createdUser.updatedAt,
      },
      token,
      refreshToken,
    };
  }

  async login(request: LoginRequest): Promise<AuthResponse> {
    // Find user by email
    const user = await this.userRepository.findByEmail(request.email);
    if (!user) {
      throw new Error('Invalid email or password');
    }

    // Verify password
    const isPasswordValid = await this.verifyPassword(request.password, user.password);
    if (!isPasswordValid) {
      throw new Error('Invalid email or password');
    }

    // Generate token
    const token = this.generateToken(user.id);
    const refreshToken = this.generateRefreshToken(user.id);

    return {
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt,
      },
      token,
      refreshToken,
    };
  }

  async refreshToken(oldRefreshToken: string): Promise<AuthResponse> {
    try {
      const decoded = verify(oldRefreshToken, AppConfig.jwtRefreshSecret) as any;
      const user = await this.userRepository.findById(decoded.userId);

      if (!user) {
        throw new Error('User not found');
      }

      const newToken = this.generateToken(user.id);
      const newRefreshToken = this.generateRefreshToken(user.id);

      return {
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          createdAt: user.createdAt,
          updatedAt: user.updatedAt,
        },
        token: newToken,
        refreshToken: newRefreshToken,
      };
    } catch (error) {
      throw new Error('Invalid or expired refresh token');
    }
  }

  async verifyToken(token: string): Promise<{ userId: string } | null> {
    try {
      const decoded = verify(token, AppConfig.jwtSecret) as any;
      return { userId: decoded.userId };
    } catch (error) {
      return null;
    }
  }

  private generateToken(userId: string): string {
    return sign({ userId }, AppConfig.jwtSecret, { expiresIn: AppConfig.jwtExpiresIn });
  }

  private generateRefreshToken(userId: string): string {
    return sign({ userId }, AppConfig.jwtRefreshSecret, { expiresIn: AppConfig.jwtRefreshExpiresIn });
  }

  private async hashPassword(password: string): Promise<string> {
    const saltRounds = 10;
    return await bcrypt.hash(password, saltRounds);
  }

  private async verifyPassword(password: string, hashedPassword: string): Promise<boolean> {
    return await bcrypt.compare(password, hashedPassword);
  }
}
