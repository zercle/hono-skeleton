import { injectable, inject } from 'tsyringe';
import { sign, verify } from 'jsonwebtoken';
import { IAuthUseCase } from './interfaces/auth.usecase.interface';
import { IUserRepository } from '../repository/interfaces/user.repository.interface';
import { AuthResponse, LoginRequest, RegisterRequest, User } from '../domain/models/user.model';
import { AppConfig } from '../infrastructure/config/app.config';

@injectable()
export class AuthUseCase implements IAuthUseCase {
  constructor(@inject('IUserRepository') private userRepository: IUserRepository) {}

  async register(request: RegisterRequest): Promise<AuthResponse> {
    // Check if user already exists
    const existingUser = await this.userRepository.findByEmail(request.email);
    if (existingUser) {
      throw new Error('User already exists with this email');
    }

    // Hash password (in production, use bcrypt)
    const hashedPassword = await this.hashPassword(request.password);

    // Create user
    const newUser: User = {
      id: '', // Will be generated by Prisma
      email: request.email,
      password: hashedPassword,
      name: request.name,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    const createdUser = await this.userRepository.create(newUser);

    // Generate token
    const token = this.generateToken(createdUser.id);

    return {
      user: {
        id: createdUser.id,
        email: createdUser.email,
        name: createdUser.name,
        createdAt: createdUser.createdAt,
        updatedAt: createdUser.updatedAt,
      },
      token,
    };
  }

  async login(request: LoginRequest): Promise<AuthResponse> {
    // Find user by email
    const user = await this.userRepository.findByEmail(request.email);
    if (!user) {
      throw new Error('Invalid email or password');
    }

    // Verify password (in production, use bcrypt.compare)
    const isPasswordValid = await this.verifyPassword(request.password, user.password);
    if (!isPasswordValid) {
      throw new Error('Invalid email or password');
    }

    // Generate token
    const token = this.generateToken(user.id);

    return {
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt,
      },
      token,
    };
  }

  async verifyToken(token: string): Promise<{ userId: string } | null> {
    try {
      const decoded = verify(token, AppConfig.jwtSecret) as any;
      return { userId: decoded.userId };
    } catch (error) {
      return null;
    }
  }

  private generateToken(userId: string): string {
    return sign({ userId }, AppConfig.jwtSecret, { expiresIn: AppConfig.jwtExpiresIn });
  }

  private async hashPassword(password: string): Promise<string> {
    // For demo purposes, using simple hashing. In production, use bcrypt!
    return Buffer.from(password).toString('base64');
  }

  private async verifyPassword(password: string, hashedPassword: string): Promise<boolean> {
    // For demo purposes, using simple comparison. In production, use bcrypt.compare!
    const hash = Buffer.from(password).toString('base64');
    return hash === hashedPassword;
  }
}
